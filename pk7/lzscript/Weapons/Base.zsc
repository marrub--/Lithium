// ╭──────────────────────────────────────────────────────────────────────────╮
// │                                                                          │
// │             Distributed under the CC0 public domain license.             │
// │   By Alison G. Watson. Attribution is encouraged, though not required.   │
// │                See licenses/cc0.txt for more information.                │
// │                                                                          │
// ╰──────────────────────────────────────────────────────────────────────────╯

class Lith_WeaponScopedToken : Inventory {default {Inventory.MaxAmount 1;}}

class Lith_Weapon : Weapon;

enum Lith_PSprite {
   _psp_weapon = psp_weapon,
   _psp_double_lg,
   _psp_double_rg,
   _psp_wep_max,

   _psp_flash = psp_flash,
   _psp_double_lf,
   _psp_double_rf,
   _psp_d_subweapon,
   _psp_flash_max,

   _psp_rems_particle_first,
   _psp_rems_particle_last = _psp_rems_particle_first + 70,

   _psp_overlay_hax = 69420,
}

enum Lith_Hand {
   _rhs,
   _lhs,
}

enum Lith_Oscillate {
   _no_oscill,
   _oscillate,
}

enum Lith_TracerType {
   _tr_normal,
   _tr_slow,
   _tr_big,
   _tr_none
}

enum Lith_RaiseSpeed {
   _raise_slow,
   _raise_normal,
   _raise_fast,
   _raise_instant
}

enum Lith_MeleeFlags {
   _mlf_pull_in,
   _mlf_no_turn,
   _mlf_damage_stepup,
}

default {
   Inventory.PickupMessage "";
   Inventory.PickupSound "";
   Lith_Weapon.ScopeInSound "weapons/shotgun/zoomin";
   Lith_Weapon.ScopeOutSound "weapons/shotgun/zoomout";
   Lith_Weapon.ScopeZoom 1.0;
   Lith_Weapon.DefaultSpeed 1.0;
   Lith_Weapon.SprintSpeed 2.0;
   Weapon.BobSpeed 1.5;
   Weapon.BobStyle "InverseSmooth";

   +Inventory.UnTossable
   +Weapon.NoAlert
}

int m_fired;
int m_max;
int m_firePattern;

meta sound m_scopeOutSnd;
meta sound m_scopeInSnd;
meta double m_scopeZoom;
meta double m_defaultSpeed;
meta double m_sprintSpeed;

meta class<Actor> m_spawnType;

bool m_side;
float m_speedUp;

protected bool m_ads;

class<Lith_Ammo> m_ammoType;

property AmmoType: m_ammoType;
property MagSize:  m_max;

property ScopeOutSound: m_scopeOutSnd;
property ScopeInSound:  m_scopeInSnd;
property ScopeZoom:     m_scopeZoom;

property SpawnType: m_spawnType;

property DefaultSpeed: m_defaultSpeed;
property SprintSpeed:  m_sprintSpeed;

const _psp_flags =
   PSPF_ADDWEAPON | PSPF_ADDBOB | PSPF_ALPHA | PSPF_RENDERSTYLE;

virtual double, double lith_getFirePattern() {return 0, 0;}
virtual bool           lith_checkSprint()    {return false;}

virtual state lith_ready(int flags) {
   if(lith_checkSprint()) {
      return resolveState("_Sprint");
   } else {
      return null;
   }
}

virtual void lith_reloadFinish(bool isAuto) {m_fired = 0;}
override void markPrecacheSounds() {
   super.markPrecacheSounds();
   markSound(m_scopeOutSnd);
   markSound(m_scopeInSnd);
}

override double getSpeedFactor() {
   return owner && owner.player.readyWeapon == self ? m_speedUp : 1;
}

override void beginPlay() {
   super.beginPlay();
   m_speedUp = m_defaultSpeed;
}

int lith_getRaiseSpeed(Lith_RaiseSpeed speed) {
   switch(speed) {
   case _raise_slow:    return 10;
   case _raise_normal:  return 12;
   case _raise_fast:    return 18;
   case _raise_instant: return 60;
   default:             throwAbortException("invalid raise speed");
   }
   return 0;
}

bool lith_magEmpty() {return m_fired >= m_max;}

bool lith_noAmmo(int minAmount = 1) const {
   return m_ammoType && owner.countInv(m_ammoType) < minAmount;
}

action(Weapon) void lith_a_setInterpolation(bool on) {
   for(int psp = _psp_weapon; psp < _psp_wep_max; ++psp) {
      a_overlayFlags(psp, pspf_interpolate, on);
   }
}

action(Weapon) void lith_a_overlayTick() {
   float a = 1.0;
   int style = style_normal;
   if(countInv("Lith_WeaponScopedToken")) {
      a = lith_weapons_scopealpha;
      style = style_subtract;
   } else if(!invoker.m_ads) {
      a_zoomFactor(1.0, ZOOM_INSTANT);
   }
   a *= Lith_UTIL.pData(_pdt_alpha) / FIX;

   for(int psp = _psp_weapon;; ++psp) {
      if(psp == _psp_wep_max) {
         psp = _psp_flash;
      } else if(psp == _psp_flash_max) {
         break;
      }

      a_overlayFlags(psp, pspf_alpha|pspf_renderstyle, true);
      if(style != style_normal) {
         a_overlayRenderStyle(psp, style);
      }
      a_overlayAlpha(psp, a);

      if(Lith_Player(self).m_wasDamaged) {
         a_overlayTranslation(psp, "Lith_FuckUp" .. random(1, 4));
      } else {
         a_overlayTranslation(psp, '');
      }
   }
}

action(Weapon) void Lith_A_Lower(Lith_RaiseSpeed speed) {
   if(!player) {
      return;
   }

   if(!player.readyWeapon) {
      lith_a_setInterpolation(false);
      player.mo.bringUpWeapon();
      return;
   }

   int lowerSpeed = invoker.lith_getRaiseSpeed(speed);
   let psp = player.getPSprite(_psp_weapon);
   if(psp) {
      lith_a_setInterpolation(true);

      if(player.morphTics || player.cheats & cf_instantweapswitch) {
         psp.y = weaponBottom;
      } else {
         psp.y += lowerSpeed;
      }

      if(psp.y < weaponBottom) {
         return;
      }

      resetPSprite(psp);
      if(player.playerState == pst_dead) {
         lith_a_setInterpolation(false);
         player.setPSprite(_psp_flash, null);
         psp.setState(findState('DeadLowered'));
         return;
      }

      lith_a_setInterpolation(false);
      player.setPSprite(_psp_flash, null);
      player.mo.bringUpWeapon();
   }
}

action(Weapon) void Lith_A_Raise(Lith_RaiseSpeed speed) {
   if(!player) {
      return;
   }

   if(player.pendingWeapon != WP_NOCHANGE) {
      player.mo.dropWeapon();
      return;
   }

   if(!player.readyWeapon) {
      return;
   }

   int raiseSpeed = invoker.lith_getRaiseSpeed(speed);
   let psp = player.getPSprite(_psp_weapon);
   if(psp) {
      if(psp.y <= weaponBottom) {
         resetPSprite(psp);
      }

      psp.y -= raiseSpeed;
      if(psp.y > weaponTop) {
         return;
      }
      psp.y = weaponTop;

      psp.setState(invoker.getReadyState());
   }
}

action(Weapon) state Lith_A_DoubleReady() {
   if(health < 1) return resolveState("Null");
   else           return null;
}

action(Weapon) void Lith_A_DoubleRaise() {
   A_Overlay(_psp_double_lg, "ReadyLH");
   A_Overlay(_psp_double_rg, "ReadyRH");
   A_OverlayFlags(_psp_double_lg, _psp_flags, true);
   A_OverlayFlags(_psp_double_rg, _psp_flags, true);
}

action(Weapon) void Lith_A_DoubleState(bool oscillate, statelabel lh, statelabel rh) {
   if(oscillate) {
      invoker.m_side = !invoker.m_side;
      if(invoker.m_side) A_Overlay(_psp_double_lg, lh);
      else               A_Overlay(_psp_double_rg, rh);
   } else {
      A_Overlay(_psp_double_lg, lh);
      A_Overlay(_psp_double_rg, rh);
   }
}

action(Weapon) void Lith_A_DoubleOffset(bool left, int x, int y, int flags = 0) {
   int fst = left ? _psp_double_lg : _psp_double_rg;
   int snd = left ? _psp_double_lf : _psp_double_rf;
   A_OverlayOffset(fst, x, y, flags);
   A_OverlayOffset(snd, x, y, flags);
}

action(Weapon) state Lith_A_Ready(int flags = 0) {
   let psp = player.getPSprite(_psp_overlay_hax);
   if(!psp || !psp.curState) {
      A_Overlay(_psp_overlay_hax, "_MultithreadedFuckingOverlaysBecauseGodIsDeadAndGrafZahlKilledHim");
   }

   let st = invoker.lith_ready(flags);
   if(st) {
      return st;
   } else {
      a_weaponReady(flags | callACS("Lith_GetWRF"));
      return null;
   }
}

action(Weapon) state Lith_A_JumpIfMagEmpty(bool autoreload = true, statelabel rsn = "Reload", statelabel esn = "FireEmpty") {
   statelabel sn;
   if(autoreload) {
      if(lith_weapons_reloadempty) {
         sn = rsn;
      } else {
         sn = esn;
      }
   } else {
      sn = rsn;
   }
   if(invoker.lith_magEmpty()) {
      if(sn == "FireEmpty") {
         lith_a_setInterpolation(true);
      }
      return ResolveState(sn);
   } else {
      return null;
   }
}

action(Weapon) state Lith_A_JumpIfMagFull(statelabel sn = "ReadySelector") {
   return invoker.m_fired ? null : ResolveState(sn);
}

action(Weapon) void Lith_A_MagIncr(int amt = 1) {
   if(!Lith_UTIL.pData(_pdt_upgrade, UPGR_OneShot))
      invoker.m_fired = min(invoker.m_fired + amt, invoker.m_max);
   else
      invoker.m_fired = invoker.m_max;
}

action(Weapon) void Lith_A_ReloadFinish() {
   invoker.Lith_ReloadFinish(false);
}

action(Weapon) void Lith_A_RecoilUp(double amt) {
   double v = lith_weapons_recoil * amt;
   CallACS("Lith_RecoilUp", int(v * FIX));
}

action(Weapon) void Lith_A_RecoilDn(double amt) {
   double v = lith_weapons_recoil * (-amt/4);
   CallACS("Lith_RecoilUp", int(v * FIX));
}

action(Weapon) void Lith_A_ReloadBobUp(double amt) {
   double v = lith_weapons_reloadbob * amt;
   CallACS("Lith_RecoilUp", int(v * FIX));
}

action(Weapon) void Lith_A_ReloadBobDn(double amt) {
   double v = lith_weapons_reloadbob * -amt;
   CallACS("Lith_RecoilUp", int(v * FIX));
}

action(Weapon) void Lith_A_ScopeIn() {
   if(!CountInv("Lith_WeaponScopedToken")) {
      self.GiveInventory("Lith_WeaponScopedToken", 1);
      A_ZoomFactor((1+lith_weapons_zoomfactor)*invoker.m_scopeZoom);
      A_StartSound(invoker.m_scopeInSnd, lch_scope);
   }
}

action(Weapon) void Lith_A_CancelScope() {
   invoker.m_ads = false;
   self.TakeInventory("Lith_WeaponScopedToken", 1);
   A_ZoomFactor(1.0, ZOOM_INSTANT);
}

action(Weapon) void Lith_A_ScopeOut() {
   if(CountInv("Lith_WeaponScopedToken")) {
      Lith_A_CancelScope();
      A_StartSound(invoker.m_scopeOutSnd, lch_scope);
   }
}

action(Weapon) void Lith_A_ScopeToggle() {
   if(CountInv("Lith_WeaponScopedToken")) Lith_A_ScopeOut();
   else                                   Lith_A_ScopeIn();
}

action(Weapon) void Lith_A_ZoomFactorScoped(double amount) {
   A_ZoomFactor((1+lith_weapons_zoomfactor) * amount * invoker.m_scopeZoom);
}

action(Weapon) void Lith_GunSmoke(class<Actor> type, double x = 0, double y = 6, bool ignoreCrouch = false) {
   if(!ignoreCrouch) (y -= ((1.0 - GetCrouchFactor(AAPTR_DEFAULT)) * 10.0));
   A_FireProjectile(type, 0, 0, x, y, FPF_NOAUTOAIM);
}

action(Weapon) void Lith_A_GunSmoke(double x = 0, double y = 6, bool ignoreCrouch = false) {
   Lith_GunSmoke("Lith_GunSmokeSpawner", x, y, ignoreCrouch);
}

action(Weapon) void Lith_A_GunSmokeSmall(double x = 0, double y = 6, bool ignoreCrouch = false) {
   Lith_GunSmoke("Lith_GunSmokeSpawnerSmall", x, y, ignoreCrouch);
}

action(Weapon) void Lith_A_DropMag(class<Lith_DroppedMagazine> mag1, class<Lith_DroppedMagazine> mag2, double px, double py, double pz, double vx, double vy, double vz) {
   double vh = Player.ViewZ - Player.MO.ViewHeight - Pos.Z;
   px += FRandom(-1, 1); py += FRandom(-1, 1); pz += FRandom(-1, 1);
   vx += FRandom(-1, 1); vy += FRandom(-1, 1); vz += FRandom(-1, 1);
   A_SpawnItemEx(invoker.Lith_MagEmpty() || !mag2 ? mag1 : mag2, px,py,pz+vh, vx,vy,vz);
}

action(Weapon) void Lith_A_Casing(class<Lith_CasingBase> cas, double px, double py, double pz, double vx, double vy, double vz) {
   double vh = Player.ViewZ - Player.MO.ViewHeight - Pos.Z;
   px += FRandom(-1, 1); py += FRandom(-1, 1); pz += FRandom(-1, 1);
   vx += FRandom(-1, 1); vy += FRandom(-1, 1); vz += FRandom(-1, 1);
   A_SpawnItemEx(cas, Cos(Pitch)*px, py, pz-Sin(Pitch)*px+vh, vx, vy, vz);
}

action(Weapon) void Lith_FixedBullets(int numBullets, int damage, int flags = 0, class<Actor> puffType = "Lith_BulletPuff", double tracerX = 0, double range = 8192) {
   for(int i = 0; i < numBullets; i++) {
      double p, y; [p, y] = invoker.Lith_GetFirePattern();
      Lith_FireBullets(p, y, -1, damage, FBF_EXPLICITANGLE | FBF_NORANDOM | flags, puffType, tracerX, range);
   }
}

action(Weapon) void Lith_FireBullets(double spreadHorz, double spreadVert, int numBullets, int damage, int flags = 0, class<Actor> puffType = "Lith_BulletPuff", double tracerX = 0, double range = 8192, Lith_TracerType tracer = _tr_normal) {
   class<Actor> tracerType;
   switch(tracer) {
   case _tr_normal: tracerType = "Lith_BulletTracer";     break;
   case _tr_slow:   tracerType = "Lith_BulletTracerSlow"; break;
   case _tr_big:    tracerType = "Lith_BulletTracerBig";  break;
   case _tr_none:   tracerType = null;                    break;
   }
   A_FireBullets(spreadHorz, spreadVert, numBullets, damage, puffType, flags, range, tracerType, 7 + FRandom(-1, 0), tracerX + FRandom(-0.7, 0.7));
}

action(Weapon) void lith_a_fireMelee(int damage, double range, int flags = 0, class<Actor> puffType = "Lith_BulletPuff") {
   if(!player) {
      return;
   }

   FTranslatedLineTarget lt;

   double y = angle + random2() * (5.625 / 256.0);
   double p = aimLineAttack(y, range, lt, 0, ALF_CHECK3D);

   if(lt.lineTarget) {
      if(flags & _mlf_damage_stepup) {
         double rad  = radius - lt.lineTarget.radius;
         double dist = lt.lineTarget.distance2D(self) - rad;
         double rnge = range - rad;
         if(dist >= rnge) {
            damage *= 2;
         } else {
            damage = int(double(damage) * (1.0 + dist / rnge));
         }
      }
   }

   Actor puff;
   int doneDamage;
   [puff, doneDamage] = lineAttack(y, range, p, damage, 'Melee', puffType, LAF_ISMELEEATTACK, lt);

   if(lt.lineTarget) {
      if(!(flags & _mlf_no_turn)) {
         angle = lt.angleFromSource;
      }
      if(flags & _mlf_pull_in) {
         bJustAttacked = true;
      }
   }
}

action(Weapon) State lith_jumpNoAmmo(int minAmount = 1, stateLabel label = "FireEmpty") {
   if(invoker.lith_noAmmo(minAmount)) {
      if(label == "FireEmpty") {
         lith_a_setInterpolation(true);
      }
      return resolveState(label);
   } else {
      return null;
   }
}

action(Weapon) void lith_takeAmmo(int amount = 1) {
   self.takeInventory(invoker.m_ammoType, amount, noTakeInfinite: true);
}

action(Weapon) State lith_jumpAmmo(int maxAmount, stateLabel label) {
   if(self.countInv(invoker.m_ammoType) >= maxAmount) {
      return resolveState(label);
   } else {
      return null;
   }
}

action(Weapon) clearScope int lith_maxInv(class<Inventory> itemType) {
   let item = findInventory(itemType);
   if(item) {
      return item.maxAmount;
   } else {
      return getDefaultByType(itemType).maxAmount;
   }
}

action(Weapon) void lith_sprint() {
   invoker.m_speedUp = invoker.m_sprintSpeed;
}

action(Weapon) state lith_jumpIfSprint() {
   if(vel.xy.length() < 8) {
      player.getPSprite(_psp_weapon).frame = 99;
   }

   if(getPlayerInput(INPUT_BUTTONS) & BT_SPEED == 0) {
      invoker.m_speedUp = invoker.m_defaultSpeed;
      return resolveState("_SprintDone");
   } else {
      return null;
   }
}

states(Actor) {
Spawn:
   TNT1 A 0;
   TNT1 A 0 {
      /* UDMF maps have a surprising amount of control over things, so we
       * have to use a load of flags to make this work properly.
       */
      if(!bDROPPED && m_spawnType)
         A_SpawnItemEx(m_spawnType, flags:
                       SXF_TRANSFERTRANSLATION | SXF_TRANSFERAMBUSHFLAG  |
                       SXF_TRANSFERPITCH       | SXF_TRANSFERPOINTERS    |
                       SXF_TRANSFERSCALE       | SXF_TRANSFERSPECIAL     |
                       SXF_TRANSFERSTENCILCOL  | SXF_TRANSFERALPHA       |
                       SXF_TRANSFERRENDERSTYLE | SXF_TRANSFERSPRITEFRAME |
                       SXF_TRANSFERROLL);
   }
   stop;
}

states(Weapon) {
_MultithreadedFuckingOverlaysBecauseGodIsDeadAndGrafZahlKilledHim:
   TNT1 A 1 lith_a_overlayTick();
   loop;
FireEmpty:
ReadySelector:
   #### # 0 {
      lith_a_setInterpolation(false);
      return CountInv("Lith_WeaponScopedToken") || invoker.m_ads
         ? ResolveState("AltReady")
         : ResolveState("Ready");
   }
   stop;
DummyFlash:
   TNT1 A 0 A_AlertMonsters;
   stop;
}

/* EOF */
