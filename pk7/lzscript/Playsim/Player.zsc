// ╭──────────────────────────────────────────────────────────────────────────╮
// │                                                                          │
// │             Distributed under the CC0 public domain license.             │
// │   By Alison G. Watson. Attribution is encouraged, though not required.   │
// │                See licenses/cc0.txt for more information.                │
// │                                                                          │
// ╰──────────────────────────────────────────────────────────────────────────╯

extend class Lith_HERMES;

struct HermesData clearScope {
   string logName;
   string bipName;
}

private HermesData m_data;

static clearScope double GetViewHeight(Actor mo) {
   return Lith_Player(mo).player.viewz - mo.pos.z;
}

static clearScope double GetAttackHeight(Actor mo) {
   return mo.height / 2.0 + mo.player.mo.attackZOffset * mo.player.crouchFactor;
}

static ui void Project(Actor mo, double x_, double y_, double z_, int px, int py, int pv) {
   int x, y; bool v; [x, y, v] = Lith_URANUS.instance().project((x_, y_, z_));
   if(px) ACS_ExecuteWithResult(lsc_setptri32,  px, x);
   if(py) ACS_ExecuteWithResult(lsc_setptri32,  py, y);
   if(pv) ACS_ExecuteWithResult(lsc_setptrbool, pv, v);
}

static void TraceFrom(Actor mo, double yaw, double pitch, double dist, double offsetz, bool floor, int px, int py, int pz) {
   vector3 v = Lith_UTIL.TraceFrom(mo, yaw * 360, pitch * 360, dist, offsetz, floor);
   if(px) ACS_ExecuteWithResult(lsc_setptrk32, px, int(v.x * FIX));
   if(py) ACS_ExecuteWithResult(lsc_setptrk32, py, int(v.y * FIX));
   if(pz) ACS_ExecuteWithResult(lsc_setptrk32, pz, int(v.z * FIX));
}

static void PlayerInit(Actor mo_) {
   let mo = Lith_Player(mo_);
   /* mo.m_cs = Lith_Cyberspace.create(); */
   mo.m_light = Lith_Flashlight.create(mo);
}

static void Nuke(Actor mo) {
   mo.A_StartSound("player/nuke", lch_body2, attenuation: ATTN_NONE);
   for(let it = BlockThingsIterator.Create(mo, 6144); it.next();)
      if(it.thing.bSHOOTABLE && it.thing.checkSight(mo) && !it.thing.player)
         DieMonster(it.thing);
   mo.A_AlertMonsters();
}

static void PlayerDeath(Actor mo) {
   mo.A_Quake(9, 35*2, 0, 2048);
   mo.A_StartSound("player/death2", lch_body3, attenuation: ATTN_NONE);
   for(int i = 0; i < 76; i++)
      mo.A_SpawnItemEx("Lith_PlayerDeathParticle", FRandom(-32,32), FRandom(-32,32), FRandom(0, 64), FRandom(-2, 2), FRandom(-2, 2), FRandom(1, 2), 0, SXF_NOCHECKPOSITION);
}

static void PlayerDeathNuke(Actor mo) {
   for(int i = 0; i < 76; i++)
      mo.A_SpawnItemEx("Lith_PlayerDeathParticle2", FRandom(-32,32), FRandom(-32,32), FRandom(0, 64), FRandom(-16, 16), FRandom(-16, 16), FRandom(1.5, 2.5), 0, SXF_NOCHECKPOSITION);
   Nuke(mo);
}

static string GetObituary()
{
   let sv = Instance();
   if(sv) return sv.m_Obituary;
   else   return "";
}

static void DeleteItem(Actor mo, int item)
{
   let id = Lith_IDOL(mo.FindInventory("Lith_IDOL"));
   if(id) id.Lith_Remove(item);
}

static bool UseItem(Actor mo, int item)
{
   let id = Lith_IDOL(mo.FindInventory("Lith_IDOL"));
   if(id) return id.Lith_Use(item);
   else   return false;
}

static string GetLogName() {
   return instance().m_data.logName;
}

static clearScope void Log(int type, int levl, string name) {
   let sv = instance();
   if(sv) {
      sv.m_data.logName = name;
      callAcs("Lith_LogS", levl, type);
   }
}

static string GetBipName() {
   return instance().m_data.bipName;
}

static void UnlockBip(Actor mo, string name) {
   let sv = Instance();
   if(sv && mo.Player) {
      sv.m_data.bipName = name;
      mo.ACS_ScriptCall("Lith_BIPUnlock");
   }
}

static bool AdrenalineCheck(Actor mo)
{
   Actor th;
   for(let it = ThinkerIterator.Create("Actor"); (th = Actor(it.Next()));)
      if(th.bMISSILE && th.Target && th.Target.bCOUNTKILL && !th.IsZeroDamage() &&
         th.Vec3To(mo).Length() <= 100)
         return true;
   return false;
}

/* EOF */
